<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2:1</title>
    <style>
        #form {
            display: none;
        }

        .text #form {
            display: flex;
            flex-direction: column;
        }

        #editor {
            position: fixed;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
        }

        .text #editor {
            display: none;
        }
    </style>
</head>
<body>
    <svg id="editor" height="1000" width="1000">
        <style>
            text {
                font-size:22.5778px;font-family:sans-serif;fill:#000000;
            }
        </style>
    </svg>

    <div id="form">
        <div>
            <input id="name">
        </div>
        <div>
            <textarea id="text" cols="30" rows="10"></textarea>
        </div>
        <div>
            <button id="submit">submit</button>
        </div>
    </div>
</body>
<script type="module">
    {
        const name = document.querySelector('#name'),
            text = document.querySelector('#text');
        document.querySelector('#submit').addEventListener('click', () => {
            fetch('/', { method: 'POST', body: JSON.stringify({
                name: name.value,
                text: text.value
            })}).then(console.log, console.error);
        });
    }

    {
        // represents one line in the program, displayed as a block.
        class Block {
            constructor(size) {
                if (!Block.#validSizes.has(size)) {
                    throw new RangeError('size must be 0, 1, 2, or 3');
                }
                this.size = size;
                this.elem = document.createElementNS('http://www.w3.org/2000/svg', 'use');
                this.elem.setAttribute('href', `block.svg#block-${size}`);
                this.elem[ownerBlock] = this;
                SVGRoot.append(this.elem);
            }

            static #validSizes = new Set([0,1,2,3]);
        }

        const SVGRoot = document.querySelector('svg');
        const ownerBlock = Symbol('ownerBlock');

        // allow dragging and dropping:

        const TrueCoords = SVGRoot.createSVGPoint();
        const GrabPoint = SVGRoot.createSVGPoint();
        let dragTarget = null;

        SVGRoot.addEventListener('mousedown', ({ target }) => {
            // only allow dragging blocks
            if (ownerBlock in target) {
                dragTarget = target;

                // move this element to the "top" of the display, so it is over other elements
                dragTarget.parentNode.appendChild(dragTarget);
        
                // turn off all pointer events to the dragged element, this does 2 things:
                //    1) allows us to drag text elements without selecting the text
                //    2) allows us to find out where the dragged element is dropped (see Drop)
                dragTarget.setAttributeNS(null, 'pointer-events', 'none');

                // we need to find the current position and translation of the grabbed element,
                //    so that we only apply the differential between the current location
                //    and the new location
                var transMatrix = dragTarget.getCTM();
                GrabPoint.x = TrueCoords.x - transMatrix.e;
                GrabPoint.y = TrueCoords.y - transMatrix.f;
            }
        });

        SVGRoot.addEventListener('mousemove', evt => {
            // account for zooming and panning
            getTrueCoords(evt);

            // if we don't currently have an element in tow, don't do anything
            if (dragTarget) {
                // account for the offset between the element's origin and the
                // exact place we grabbed it... this way, the drag will look more natural
                dragTarget.setAttributeNS(null, 'transform', `translate(${
                    TrueCoords.x - GrabPoint.x}, ${
                    TrueCoords.y - GrabPoint.y})`);
            }
        });

        SVGRoot.addEventListener('mouseup', ({ target }) => {
            // if we aren't currently dragging an element, don't do anything
            if (dragTarget) {
                // turn the pointer-events back on, so we can grab this item later
                dragTarget.setAttributeNS(null, 'pointer-events', 'all');

                // set the variable to null, so nothing will be dragged until we
                // grab the next element
                dragTarget = null;
            }
        });


        function getTrueCoords(evt) {
            // find the current zoom level and pan setting, and adjust the reported
            //    mouse position accordingly
            const newScale = SVGRoot.currentScale;
            const translation = SVGRoot.currentTranslate;
            TrueCoords.x = (evt.clientX - translation.x) / newScale;
            TrueCoords.y = (evt.clientY - translation.y) / newScale;
        }
    }
</script>
</html>